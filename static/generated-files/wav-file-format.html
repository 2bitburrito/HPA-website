<p>+++
date = '2025-09-14T20:30:05+10:00'
draft = true
title = 'The Wav File Format'
+++</p>
<h4><em>A deep dive into wav files used in Broadcast applications</em></h4>
<p>As audio professionals we make, delete, edit, crush, fix and split wav files every day. But have you ever really looked into a wav file and why it works the way that it does? Let's examine a bit of the underlying low level implementation of the standard.</p>
<h3>The History</h3>
<p>The Wav file container has been around since 1991 and was introduced by Microsoft and IBM as part of a larger project to create a standardised container for multimedia called RIFF. It soon became widely used as a format for pro audio files due to its lossless nature and ability to hold 24bit / 48kHz files.</p>
<p>Then in 1997 the “European Broadcasting Union” (EBU) extended the format to BWF (Broadcast Wave Format) which kept the same structure for a wav file while adding a <code>BEXT</code> chunk. The bext chunk contains a structured format for storing data such as timecode data sample rate etc. While this bext chunk is useful it is also severely lacking when it comes to the metadata needed for a professional  Location Sound workflow due to character limitations and inflexible input fields. This is where iXML comes in but more on that shortly.</p>
<h3>Wav File Structure</h3>
<p>First let's have a look at what a typical file is actually made up of. At a low level all files are just ones and zeros known as a bit. We typically group a series of bits together into groups of 8 known as a byte (fun fact: a half byte or 4x bits is known as a nibble).</p>
<p>So a typical byte looks like this: <code>01101101</code> and will allow for a maximum of 256 values (or 2<!-- raw HTML omitted -->8<!-- raw HTML omitted -->). Readers familiar with MIDI will recognise this value as the range of values that midi channels use to communicate.</p>
<p>However those of you who remember the sound from the original NES will know that 8-bits per sample aren't enough to realistically represent the human voice. In order to do that we must stack multiple bytes together into a longer word. This is where we get 24bit (and the newer 32bit). This gives us over 16 million points to choose from per sample.</p>
<p>But a wav file is much more than just a collection of samples as we have discussed. A wav file will always need to contain several other chunks containing key data.</p>
<p>![[IMG_6966.jpeg]]</p>
<p><em><a href="https://tech.ebu.ch/docs/tech/tech3306v1_0.pdf">Source</a></em></p>
<p>The structure of a basic wav file is as follows:</p>
<ul>
<li>
<p><strong>RIFF</strong>: The file begins with the ASCII characters RIFF, identifying the file format as a RIFF file.</p>
</li>
<li>
<p><strong>Size</strong>: Immediately after ‘RIFF’, a 4-byte field specifies the size of the entire RIFF data (excluding the RIFF and size fields). This 32-bit size field has a limit of 4 GB, which is why standard Wav files have a maximum size of 4 GB.</p>
</li>
<li>
<p><strong>WAVE</strong>: After the size field, the identifier WAVE indicates that this RIFF file is specifically a WAV file</p>
</li>
<li>
<p><strong>fmt</strong> : Or the format chunk. This is the first sub-chunk within the RIFF/WAVE structure, and it contains essential information about the audio format for interpreting the raw audio data in the file such as:</p>
<ul>
<li>‘fmt ‘: This ASCII string identifies the chunk as the format chunk.</li>
<li>Size: The following 4-byte field indicates the size of the format data.</li>
<li>Audio format (e.g., PCM for uncompressed audio).</li>
<li>Number of channels (e.g., 1 for mono, 2 for stereo).</li>
<li>Sample rate (e.g., 44100 Hz).</li>
<li>... And a few more fields</li>
</ul>
</li>
<li>
<p><strong>data</strong>: This is the data chunk that contains the actual audio data, organised as a series of samples including a sub-header which indicates the size of the remaining audio data. This is the actual audio data, which is typically encoded in PCM format. Each sample is arranged according to the format specified in the fmt  chunk. For example, in a 4 channel polywav, 24-bit WAV file, each sample consists of four 24-bit values (one per channel), repeated for the duration of the recording.</p>
</li>
<li>
<p><strong>iXML</strong>: In 2003 this optional chunk was included in the specification. It allows much more flexibility in how you add metadata.</p>
</li>
</ul>
<p>![[Screenshot 2024-11-07 at 7.39.42 pm.png]]</p>
<p>As you can see it is a nested tree structure similar to many other structures in computer design (like HTML for example). These iXMLs have no constraints to how the metadata is laid out or even what metadata is included. For example in an Aaton Cantar file (RIP) they even include data such as routing information, pan pot position and Ambisonics metadata.</p>
<p>![[Screenshot 2024-11-07 at 7.41.35 pm.png]]</p>
<h6>But how do we view these fields and what does it practically look like to store data inside a wav file?</h6>
<p>I find concepts like these all academic until I can actually see them in action or interact with them in some way. That is until I discovered the ability to open these files in a hex editor. Here I'm using the free and open-source <a href="https://hexfiend.com/">Hex Fiend</a>.</p>
<p>![[Screenshot 2024-11-07 at 7.59.39 pm.png]]</p>
<p>On the left you can see the data represented in text. On the left is Hexadecimal (a base 16 digit) which is in essence an easier way for developers to view binary as each hexadecimal represents 4 bits - making it more compact that raw binary. On the right the program is translating the hex into utf8 digits for us to read.  The beauty of this is that you can actually see the seperate chunks and headers - along with the padding in the file which allows for some flexibility in the size of the bext and ixml chunks.</p>
<p>![[Screenshot 2024-11-07 at 8.06.39 pm.png]]</p>
<h3>Editing a File's Metadata</h3>
<p>Now interestingly due to the size headers we cannot just open a text editor and mess with the metadata directly. The main reason for this is unless you have exactly the same character counts within the file your header chunks size calculations will be incorrect and thus break the wav file's expected format.</p>
<p>Instead, editing needs to be handled much more delicately on a low-level programming level. So for now there are three options although they are quite outdated and have their own drawbacks and quirks.</p>
<ul>
<li><a href="https://github.com/MediaArea/BWFMetaEdit">BWF MetaEdit</a> - This tool allows viewing of multiple different formats however it's quite an outdated interface and won't allow playback of any kind.</li>
<li><a href="https://www.sounddevices.com/product/wave-agent-software/">Wave Agent</a> - A great and very well engineered tool for it's time however it doesn't handle modern formats such as 32-bit float and RF64.</li>
<li><a href="https://metasoundtools.com">Meta Sound Tools</a> - Now time for a shameless plug: I've been working tirelessly on this app which does all of the things listed here and much more. If you're after an all in one toolbox for bwav files this is the one.</li>
</ul>
