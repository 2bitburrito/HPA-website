<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description"
    content="Hugh Palmer - Melbourne based Sound Recordist. Sound Engineer, Audio Recording and Mixing in Australia.  Specialising in sound for TVC, Doco, Corporate and Drama Film." />
  <meta name="keywords"
    content="Sound Recordist, Melbourne, Australia, Audio Recording, Sound Recordist, Audio Restoration, TVC" />
  <meta name="author" content="Hugh Palmer" />
  <title>Hugh Palmer</title>
  <link rel="stylesheet" href="/styles.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=SUSE:wght@100..800&display=swap" rel="stylesheet" />
  <link rel="icon" href="../icons/mixer1.png" type="image/x-icon" />
  <script src="https://cdn.jsdelivr.net/npm/htmx.org@2.0.7/dist/htmx.min.js"
    integrity="sha384-ZBXiYtYQ6hJ2Y0ZNoYuI+Nq5MqWBr+chMrS/RkXpNzQCApHEhOt2aY8EJgqwHLkJ" crossorigin="anonymous">
    </script>
</head>


<body>
  <nav id="mainNavbar">
  <div class="logo" id="logo">
    <a href="/">Hugh Palmer<span class="spin"> \ </span>Audio<span class="quote">"Sounds
        Rolling"</span></a>
  </div>
  <div class="hamburger">
    <span></span>
    <span></span>
    <span></span>
  </div>
  <ul>
    <li>
      <a href="/">Home</a>
    </li>
    <li>
      <a href="/blog/">Blog</a>
    </li>
    <li>
      <a href="/main/#aboutme">About</a>
    </li>
    <li>
      <a href="/main/#contact-form">Contact</a>
    </li>
  </ul>
</nav>


  
  <section style="margin-top: 100px;" class="article">
    <h2 class="article-title">The Wav File Format</h2>
    <h3 class="article-description">A deep dive into wav files used in Broadcast applications</h3>
    <div class="article-content">
      <p>As audio professionals we make, delete, edit, crush, fix and split wav files every day. But have you ever really looked into a wav file and why it works the way that it does? Let's examine a bit of the underlying low level implementation of the standard.</p>
<h3>The History</h3>
<p>The Wav file container has been around since 1991 and was introduced by Microsoft and IBM as part of a larger project to create a standardised container for multimedia called RIFF. It soon became widely used as a format for pro audio files due to its lossless nature and ability to contain high quality 24bit / 48kHz files.</p>
<p>Then in 1997 the “European Broadcasting Union” (EBU) extended the format to BWF (Broadcast Wave Format) which keeps the same structure while also adding a <code>BEXT</code> chunk. The bext chunk contains a structured format for storing data such as timecode data sample rate etc. While this bext chunk is useful it is also severely lacking when it comes to the metadata needed for a professional  Location Sound workflow due to character limitations and inflexible input fields. This is where iXML comes in but more on that shortly.</p>
<p>One major downside of <code>riff</code> is the hard 4GB limit that is imposed on files. To answer this limitation a new standard was created in 2006 by the EBU: <code>rf64</code> which now allows for much larger audio files.</p>
<h3>Wav File Structure</h3>
<p>First let's have a look at what a typical file is actually made up of. At a low level all files are just ones and zeros known as bits. We typically group a series of bits together into groups of 8, known as a byte (fun fact: a half byte or 4x bits is known as a nibble).</p>
<p>So a typical byte looks like this: <code>01101101</code> and will allow for a maximum of 256 values (or 2<sup>8</sup>). Readers familiar with MIDI will recognise this value as the range of values that midi channels use to communicate.</p>
<p>However those of you who remember the sound from the original NES will know that 8-bits per sample aren't enough to realistically represent the human voice. In order to do that we must stack multiple bytes together into a longer word. This is where we get 24bit (and the newer 32bit). This gives us over 16 million points to choose from per sample.</p>
<p>But a wav file is much more than just a collection of samples as we have discussed. A wav file will always need to contain several other chunks containing key data.</p>
<figure>
  <img src="/Images/IMG_6966.jpeg" alt="Wav Chunk Breakdown">
  <figcaption>A breakdown of a typical iXML chunk based on the standard 
    <a href="https://tech.ebu.ch/docs/tech/tech3306v1_0.pdf">[Source]</a>
  </figcaption>
</figure>
<p>The structure of a basic wav file is as follows:</p>
<blockquote>
<p>[!NOTE]
I will lay out a very basic structure of a riff file. RF64 is laid out quite differently so I haven't explained that here. If you're interested <a href="https://tech.ebu.ch/docs/tech/tech3306v1_0.pdf">the spec</a> is quite easy to read and goes into more detail</p>
</blockquote>
<ul>
<li>
<p><strong>RIFF</strong>: The file begins with the ASCII characters RIFF, identifying the file format as a RIFF file</p>
</li>
<li>
<p><strong>Size</strong>: Immediately after ‘RIFF’, a 4-byte (32bit) field specifies the size of the entire RIFF data (excluding the RIFF and size fields).</p>
</li>
<li>
<p><strong>WAVE</strong>: After the size field, the identifier WAVE indicates that this RIFF file is specifically a WAV file</p>
</li>
<li>
<p><strong>fmt</strong> : Or the format chunk. This is typically the first sub-chunk within the RIFF/WAVE structure, and it contains essential information about the audio format for interpreting the raw audio data in the file such as:</p>
<ul>
<li>Audio format (e.g., PCM for uncompressed audio).</li>
<li>Number of channels (e.g., 1 for mono, 2 for stereo).</li>
<li>Sample rate (e.g., 44100 Hz).</li>
<li>... And a few more fields</li>
</ul>
</li>
<li>
<p><strong>bext</strong>: This is a structured format for storing metadata.</p>
</li>
<li>
<p><strong>iXML</strong>: In 2003 this optional chunk was included in the specification. It allows much more flexibility in how you add metadata.</p>
</li>
<li>
<p><strong>data</strong>:  Finally the actual audio data, which is typically encoded in PCM format. Each sample is arranged according to the format specified in the fmt  chunk. For example, in a 4 channel polywav, 24-bit WAV file, each sample consists of four 24-bit values (one per channel), repeated for the duration of the recording.</p>
</li>
</ul>
<figure>
  <img src="/Images/ixml-extracted.png" alt="iXML extracted">
  <figcaption>An example of an iXML chunk extracted from a wav file</figcaption>
</figure>
<p>As you can see it is a nested xml tree structure similar to many other structures in computer science (like HTML for example). These iXMLs have no constraints to how the metadata is laid out or even what metadata is included. For example in an Aaton Cantar file (RIP) they even include data such as routing information, pan pot position and Ambisonics metadata.</p>
<figure>
  <img src="/Images/cantar-ixml.png" alt="iXML extracted" class="img-small">
  <figcaption>A section of iXML from an Aaton Cantar file</figcaption>
</figure>
<h4>But how do we view these fields and what does it practically look like to store data inside a wav file?</h4>
<p>I find concepts like these all academic until I can actually see them in action or interact with them in some way. A hex editor (or a tool like <code>xxd</code> if you're handy with the terminal) allows you to view the inner chunks of a file. Here I'm using the free and open-source <a href="https://hexfiend.com/">Hex Fiend</a>.</p>
<figure>
  <img src="/Images/hex-fiend.png" alt="Hex Fiend">
  <figcaption>A screenshot of the Hex Fiend hex editor</figcaption>
</figure>
<p>On the left you can see the data represented in text as hexadecimal (a base 16 digit) which is in essence an easier way for developers to view binary as each hexadecimal represents 4 bits - making it more compact that raw binary. On the right the program is translating this hex into ascii digits for us to read.  The beauty of this is that you can actually see the seperate chunks and headers - along with the padding in the file which allows for some flexibility in the size of the bext and ixml chunks.</p>
<h3>RF64</h3>
<p>As mentioned previously the RF64 format was developed in order to overcome the hard 4Gb limit imposed by RIFF files. This was caused by the 32bit addressing of a RIFF file in which it stores its file size. Essentially we can store <code>2&lt;sup&gt;32&lt;/sup&gt; = 4,294,967,296</code> values in a 32bit integer which is roughly 4Gb. If a RIFF file was to store a size larger than that in the <code>riff</code> chunk we'd get what's known as buffer overflow and the format breaks.</p>
<p>RF64 solves this by storing values in 64bit integers, essentially squaring our file size limit: <code>2&lt;sup&gt;64&lt;/sup&gt; = 1.8446744074e19</code>.</p>
<p>What's neat is that the spec actually tries to enforce some amount of backwards compatibility by specifying that a recording device should always begin by creating a RIFF format and only modify it to be an RF64 file after it exceeds the 4Gb limit.</p>
<h3>Editing a File's Metadata</h3>
<p>Now interestingly due to the size headers we cannot just open a text editor and mess with the metadata directly. The main reason for this is unless you have exactly the same size counts within the file your header chunks size calculations will be incorrect and thus break the wav file's expected format.</p>
<p>Instead, editing needs to be handled much more delicately on a lower programming level. As it stands now there are three options.</p>
<ul>
<li><a href="https://github.com/MediaArea/BWFMetaEdit">BWF MetaEdit</a> - This tool allows viewing of multiple different formats however it's quite an outdated interface and won't allow playback of any kind.</li>
<li><a href="https://www.sounddevices.com/product/wave-agent-software/">Wave Agent</a> - A great and very well engineered tool for it's time however it doesn't handle modern formats such as 32-bit float and RF64.</li>
<li><a href="https://metasoundtools.com">Meta Sound Tools</a> - Now time for a shameless plug: I've been working tirelessly on this app which does all of the things listed here and much more. If you're after an all in one toolbox for BWAV files then give this one a try</li>
</ul>

    </div>
    <p class="author-date">[ Hugh Palmer ] - 2025/09/14</p>
  </section>

  
  <footer>
  <div class="socials">
    <a href="https://www.linkedin.com/in/hugh-palmer-0a8139a5/" target="_blank" rel="noopener noreferrer">
      <img src="../Images/LinkedIN_white.png" alt="LinkedIn" width="30" height="30">
    </a>
    <a href="https://www.instagram.com/hughpalmerproduction/" target="_blank" rel="noopener noreferrer">
      <img src="../Images/Instagram_white.png" alt="Instagram" width="30" height="30">
    </a>
    <a href="https://github.com/2bitburrito" target="_blank" rel="noopener noreferrer">
      <img src="../Images/Github_white.png" alt="Github" width="30" height="30">
    </a>
  </div>
  <p>
    Made by me &copy; 2026 Hugh Palmer Audio - Melbourne Sound Recordist. All rights
    reserved.
  </p>
</footer>

  <script src="/index.js"></script>
</body>

</html>
