[{"Title":"My Blog Tech Stack","Description":"How I arrived at the stack for this blog","Date":"2025-12-30T00:00:00Z","HTMLContent":"\u003cp\u003eThere are lots of options for writing a blog these days. Some notable options include simply posting to an excellent website such as \u003ca href=\"https://www.medium.com\"\u003eMedium\u003c/a\u003e, creating a wordpress site or utilising a framework such as Hugo or Jekyll on a custom stack.\u003c/p\u003e\n\u003ch3\u003eRequirements:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eEasy to write (no writing html)\u003c/li\u003e\n\u003cli\u003eIdeally I can write plain html, css\u003c/li\u003e\n\u003cli\u003eAs little js as possible\u003c/li\u003e\n\u003cli\u003eNo boiler plate (Ie I want control over the stack)\u003c/li\u003e\n\u003cli\u003eWant to be extendable to have comments and likes (twitter maybe...?)\nj\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eNOTES:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bits.logic.inc/p/ai-is-forcing-us-to-write-good-code\"\u003eexample blog\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003esubscriptions?\u003c/li\u003e\n\u003cli\u003eI like to write code... So let me write the code\u003c/li\u003e\n\u003cli\u003eWould I do it like this again?\u003c/li\u003e\n\u003c/ul\u003e\n","IsDraft":true,"Filepath":"./static/blog/articles/my-blog-stack.html","FileName":"my-blog-stack"},{"Title":"The Wav File Format","Description":"A deep dive into wav files used in Broadcast applications","Date":"2025-09-14T00:00:00Z","HTMLContent":"\u003cp\u003eAs audio professionals we make, delete, edit, crush, fix and split wav files every day. But have you ever really looked into a wav file and why it works the way that it does? Let's examine a bit of the underlying low level implementation of the standard.\u003c/p\u003e\n\u003ch3\u003eThe History\u003c/h3\u003e\n\u003cp\u003eThe Wav file container has been around since 1991 and was introduced by Microsoft and IBM as part of a larger project to create a standardised container for multimedia called RIFF. It soon became widely used as a format for pro audio files due to its lossless nature and ability to contain high quality 24bit / 48kHz files.\u003c/p\u003e\n\u003cp\u003eThen in 1997 the “European Broadcasting Union” (EBU) extended the format to BWF (Broadcast Wave Format) which keeps the same structure while also adding a \u003ccode\u003eBEXT\u003c/code\u003e chunk. The bext chunk contains a structured format for storing data such as timecode data sample rate etc. While this bext chunk is useful it is also severely lacking when it comes to the metadata needed for a professional  Location Sound workflow due to character limitations and inflexible input fields. This is where iXML comes in but more on that shortly.\u003c/p\u003e\n\u003cp\u003eOne major downside of \u003ccode\u003eriff\u003c/code\u003e is the hard 4GB limit that is imposed on files. To answer this limitation a new standard was created in 2006 by the EBU: \u003ccode\u003erf64\u003c/code\u003e which now allows for much larger audio files.\u003c/p\u003e\n\u003ch3\u003eWav File Structure\u003c/h3\u003e\n\u003cp\u003eFirst let's have a look at what a typical file is actually made up of. At a low level all files are just ones and zeros known as bits. We typically group a series of bits together into groups of 8, known as a byte (fun fact: a half byte or 4x bits is known as a nibble).\u003c/p\u003e\n\u003cp\u003eSo a typical byte looks like this: \u003ccode\u003e01101101\u003c/code\u003e and will allow for a maximum of 256 values (or 2\u003csup\u003e8\u003c/sup\u003e). Readers familiar with MIDI will recognise this value as the range of values that midi channels use to communicate.\u003c/p\u003e\n\u003cp\u003eHowever those of you who remember the sound from the original NES will know that 8-bits per sample aren't enough to realistically represent the human voice. In order to do that we must stack multiple bytes together into a longer word. This is where we get 24bit (and the newer 32bit). This gives us over 16 million points to choose from per sample.\u003c/p\u003e\n\u003cp\u003eBut a wav file is much more than just a collection of samples as we have discussed. A wav file will always need to contain several other chunks containing key data.\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/Images/IMG_6966.jpeg\" alt=\"Wav Chunk Breakdown\"\u003e\n  \u003cfigcaption\u003eA breakdown of a typical iXML chunk based on the standard \n    \u003ca href=\"https://tech.ebu.ch/docs/tech/tech3306v1_0.pdf\"\u003e[Source]\u003c/a\u003e\n  \u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eThe structure of a basic wav file is as follows:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e[!NOTE]\nI will lay out a very basic structure of a riff file. RF64 is laid out quite differently so I haven't explained that here. If you're interested \u003ca href=\"https://tech.ebu.ch/docs/tech/tech3306v1_0.pdf\"\u003ethe spec\u003c/a\u003e is quite easy to read and goes into more detail\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eRIFF\u003c/strong\u003e: The file begins with the ASCII characters RIFF, identifying the file format as a RIFF file\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eSize\u003c/strong\u003e: Immediately after ‘RIFF’, a 4-byte (32bit) field specifies the size of the entire RIFF data (excluding the RIFF and size fields).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eWAVE\u003c/strong\u003e: After the size field, the identifier WAVE indicates that this RIFF file is specifically a WAV file\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003efmt\u003c/strong\u003e : Or the format chunk. This is typically the first sub-chunk within the RIFF/WAVE structure, and it contains essential information about the audio format for interpreting the raw audio data in the file such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAudio format (e.g., PCM for uncompressed audio).\u003c/li\u003e\n\u003cli\u003eNumber of channels (e.g., 1 for mono, 2 for stereo).\u003c/li\u003e\n\u003cli\u003eSample rate (e.g., 44100 Hz).\u003c/li\u003e\n\u003cli\u003e... And a few more fields\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003ebext\u003c/strong\u003e: This is a structured format for storing metadata.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eiXML\u003c/strong\u003e: In 2003 this optional chunk was included in the specification. It allows much more flexibility in how you add metadata.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003edata\u003c/strong\u003e:  Finally the actual audio data, which is typically encoded in PCM format. Each sample is arranged according to the format specified in the fmt  chunk. For example, in a 4 channel polywav, 24-bit WAV file, each sample consists of four 24-bit values (one per channel), repeated for the duration of the recording.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/Images/ixml-extracted.png\" alt=\"iXML extracted\"\u003e\n  \u003cfigcaption\u003eAn example of an iXML chunk extracted from a wav file\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eAs you can see it is a nested xml tree structure similar to many other structures in computer science (like HTML for example). These iXMLs have no constraints to how the metadata is laid out or even what metadata is included. For example in an Aaton Cantar file (RIP) they even include data such as routing information, pan pot position and Ambisonics metadata.\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/Images/cantar-ixml.png\" alt=\"iXML extracted\" class=\"img-small\"\u003e\n  \u003cfigcaption\u003eA section of iXML from an Aaton Cantar file\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003ch4\u003eBut how do we view these fields and what does it practically look like to store data inside a wav file?\u003c/h4\u003e\n\u003cp\u003eI find concepts like these all academic until I can actually see them in action or interact with them in some way. A hex editor (or a tool like \u003ccode\u003exxd\u003c/code\u003e if you're handy with the terminal) allows you to view the inner chunks of a file. Here I'm using the free and open-source \u003ca href=\"https://hexfiend.com/\"\u003eHex Fiend\u003c/a\u003e.\u003c/p\u003e\n\u003cfigure\u003e\n  \u003cimg src=\"/Images/hex-fiend.png\" alt=\"Hex Fiend\"\u003e\n  \u003cfigcaption\u003eA screenshot of the Hex Fiend hex editor\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003eOn the left you can see the data represented in text as hexadecimal (a base 16 digit) which is in essence an easier way for developers to view binary as each hexadecimal represents 4 bits - making it more compact that raw binary. On the right the program is translating this hex into ascii digits for us to read.  The beauty of this is that you can actually see the seperate chunks and headers - along with the padding in the file which allows for some flexibility in the size of the bext and ixml chunks.\u003c/p\u003e\n\u003ch3\u003eRF64\u003c/h3\u003e\n\u003cp\u003eAs mentioned previously the RF64 format was developed in order to overcome the hard 4Gb limit imposed by RIFF files. This was caused by the 32bit addressing of a RIFF file in which it stores its file size. Essentially we can store \u003ccode\u003e2\u0026lt;sup\u0026gt;32\u0026lt;/sup\u0026gt; = 4,294,967,296\u003c/code\u003e values in a 32bit integer which is roughly 4Gb. If a RIFF file was to store a size larger than that in the \u003ccode\u003eriff\u003c/code\u003e chunk we'd get what's known as buffer overflow and the format breaks.\u003c/p\u003e\n\u003cp\u003eRF64 solves this by storing values in 64bit integers, essentially squaring our file size limit: \u003ccode\u003e2\u0026lt;sup\u0026gt;64\u0026lt;/sup\u0026gt; = 1.8446744074e19\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat's neat is that the spec actually tries to enforce some amount of backwards compatibility by specifying that a recording device should always begin by creating a RIFF format and only modify it to be an RF64 file after it exceeds the 4Gb limit.\u003c/p\u003e\n\u003ch3\u003eEditing a File's Metadata\u003c/h3\u003e\n\u003cp\u003eNow interestingly due to the size headers we cannot just open a text editor and mess with the metadata directly. The main reason for this is unless you have exactly the same size counts within the file your header chunks size calculations will be incorrect and thus break the wav file's expected format.\u003c/p\u003e\n\u003cp\u003eInstead, editing needs to be handled much more delicately on a lower programming level. As it stands now there are three options.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/MediaArea/BWFMetaEdit\"\u003eBWF MetaEdit\u003c/a\u003e - This tool allows viewing of multiple different formats however it's quite an outdated interface and won't allow playback of any kind.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.sounddevices.com/product/wave-agent-software/\"\u003eWave Agent\u003c/a\u003e - A great and very well engineered tool for it's time however it doesn't handle modern formats such as 32-bit float and RF64.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://metasoundtools.com\"\u003eMeta Sound Tools\u003c/a\u003e - Now time for a shameless plug: I've been working tirelessly on this app which does all of the things listed here and much more. If you're after an all in one toolbox for BWAV files then give this one a try\u003c/li\u003e\n\u003c/ul\u003e\n","IsDraft":false,"Filepath":"./static/blog/articles/wav-file-format.html","FileName":"wav-file-format"}]